
mix archive.install hex igniter_new
mix igniter.new shop2 \
    --with phx.new \
    --install ash,ash_phoenix,ash_postgres,ash_money

---
mix ash.gen.resource Shop2.Shop.Category \
  --uuid-v7-primary-key id \
  --attribute name:string:required:public \
  --extend postgres \
  --default-actions read,destroy \
  --timestamps
---

mix ash.gen.resource Shop2.Shop.Product \
  --uuid-primary-key id \
  --attribute name:string:required:public \
  --attribute description:string:required:public \
  --attribute image:string:public \
  --attribute price:money:required:public \
  --attribute quantity_stored:integer:required:public \
  --relationship belongs_to:category:Shop2.Shop.Category:public:required \
  --extend postgres \
  --default-actions read,destroy \
  --timestamps
--

mix ash.codegen add_products_and_categories
mix ash.setup

--

mix igniter.install ash_authentication_phoenix \
  --auth-strategy password

--

mix ash.migrate

--

mix ash.gen.enum Shop2.Accounts.User.Types.Role admin,manager,employee \
  --short-name user_role

# hand edit user

mix ash.codegen add_fields_to_user

# role field using enum
attribute :role, :user_role do
    allow_nil? false
    default :user
end

--

mix ash.codegen add_fields_to_user
mix ash.migrate

--

mix ash.patch.extend Shop2.Shop.Product Ash.Policy.Authorizer
mix ash.patch.extend Shop2.Shop.Category Ash.Policy.Authorizer

# add to both
  policies do
    policy action_type([:create, :update, :destroy]) do
      authorize_if actor_attribute_equals(:role, :admin)
    end
  end

--

# in your liveviews

`socket.assigns.current_user` will be avaialable

you will pass it in as `actor: socket.assigns.current_user` whenever calling actions

--

mix ash_phoenix.gen.live Shop2.Shop Shop2.Shop.Product \
  --resource-plural products

--

# add identity on categories having a unique name

# on categories
identities do
  identity :unique_name, [:name]
end

mix ash.codegen make_categories_unique_on_name
mix ash.migrate


# modify the product create and update action to look like this

    create :create do
      primary? true
      accept [:name, :description, :image, :price, :quantity_stored]
      argument :category, :string, allow_nil?: false

      change manage_relationship(:category,
               type: :append_and_remove,
               on_no_match: :create,
               value_is_key: :name
             )
    end

    update :update do
      primary? true
      require_atomic? false
      accept [:name, :description, :image, :price, :quantity_stored]
      argument :category, :string, allow_nil?: false

      change manage_relationship(:category,
               type: :append_and_remove,
               on_no_match: :create,
               value_is_key: :name
             )
    end


# make the category create an upsert on name

create :create do
  accept [:name]
  primary? true
  upsert? true
  upsert_identity :unique_name
end
--

mix ash.patch.extend Shop2.Shop.Product Ash.Notifier.PubSub

# add to product
  pub_sub do
    module Shop2Web.Endpoint
    prefix "product"

    publish :update, ["updated", :id]
  end

--

def mount(_params, session, socket) do
  {:ok, assign(socket, current_user: session.current_user)}
end

--

actions do
    defaults [:read] # <- add this
end

update :make_admin do
  change set_attribute(:role, :admin)
end

Ash.read_first!(Shop2.Accounts.User, authorize?: false)
|> Ash.update!(action: :make_admin, authorize?: false)

Ash.read!(Shop2.Shop.Product)

Ash.create!(Shop2.Shop.Product, %{
    name: "Product 1",
    description: "Description 1",
    price: Money.new(:USD, 1000),
    quantity_stored: 10,
    category: "Category 1"
    }, authorize?: false)
